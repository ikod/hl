

#### Таймеры ###

##### Сценарии добавления и удаления таймеров. #####

Исходное состояние.

       
    -----|--------------|---
         t₀             tₓ

а) Добавление нового таймера, с временем срабатывания позднее t₀

                ↓
    -----|--------------|---
         t₀             tₓ

б) Добавление нового таймера, с временем срабатывания до t₀

      ↓
    -----|--------------|---
         t₀             tₓ

в) Удаление или срабатывание таймера t₀

         
    -----❌----|---------|---
         t₀   t₁        tₓ

д) Удаление любого таймера правее t₀

              
    -----|----❌---------|---
         t₀   t₁        tₓ

##### Инварианты: #####
* ядро всегда знает только о самом раннем таймере.
* в обрабочике событий ядра сработавший таймер всегда является самым первым (ранним)
* любая операция по добавлению/модификаций в ядре должна заканчиваться успешно
* в ядро не посылаются таймеры с Δt < 0
##### Добавление таймера #####

Любое добавление требует вставки в список (дерево).

Если передавать в ядро информацию только о самом раннем таймере
случай А не требует обращения к ядру - достаточно добавить
таймер в список в теле eventloop.

В случае Б нужно поменять в ядре таймер на более ранний.

##### Удаление и срабатывание таймера #####

Удаление не самого раннего таймера требует только его удаления из списка.

Удаление и срабатывание самого раннего таймера (а срабатывание обязано быть на самом раннем таймере),
приводит к переустановке таймера в ядре на следующий если он есть.

Если следующего таймера нет - удаляем.

Если следующий просрочен - вставляем с задержкой 0.

##### "опоздавшие" таймеры

Если обработка срабатываний требует больше времени чем интервал между таймерами, то они будут опаздывать.

Опоздавшие таймеры обрабатываются добавлением в ядро таймера с нулевой задержкой и срабатыванием в контексте обработчика событий.

##### Худшие сценарии #####

Постоянное добавление или удаление (срабатывание) самого раннего таймера.